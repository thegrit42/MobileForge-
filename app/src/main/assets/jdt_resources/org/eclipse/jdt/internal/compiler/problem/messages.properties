###############################################################################
# Copyright (c) 2000, 2025 IBM Corporation and others.
#
# This program and the accompanying materials
# are made available under the terms of the Eclipse Public License 2.0
# which accompanies this distribution, and is available at
# https://www.eclipse.org/legal/epl-2.0/
#
# SPDX-License-Identifier: EPL-2.0
#
# Contributors:
#     IBM Corporation - initial API and implementation
#		Benjamin Muskalla - Contribution for bug 239066
#		Stephan Herrmann <stephan@cs.tu-berlin.de> - Contributions for 
#							bug 185682 - Increment/decrement operators mark local variables as read
#							bug 349326 - [1.7] new warning for missing try-with-resources
#							bug 186342 - [compiler][null] Using annotations for null checking
#							bug 365662 - [compiler][null] warn on contradictory and redundant null annotations
#							bug 365531 - [compiler][null] investigate alternative strategy for internally encoding nullness defaults
#							bug 365859 - [compiler][null] distinguish warnings based on flow analysis vs. null annotations
#							bug 374605 - Unreasonable warning for enum-based switch statements
#							bug 382353 - [1.8][compiler] Implementation property modifiers should be accepted on default methods.
#							bug 382347 - [1.8][compiler] Compiler accepts incorrect default method inheritance
#							bug 388281 - [compiler][null] inheritance of null annotations as an option
#							bug 381443 - [compiler][null] Allow parameter widening from @NonNull to unannotated
#							bug 393719 - [compiler] inconsistent warnings on iteration variables
#							bug 392862 - [1.8][compiler][null] Evaluate null annotations on array types
#							bug 382789 - [compiler][null] warn when syntactically-nonnull expression is compared against null
#							bug 400761 - [compiler][null] null may be return as boolean without a diagnostic
#							bug 402028 - [1.8][compiler] null analysis for reference expressions
#							bug 401796 - [1.8][compiler] don't treat default methods as overriding an independent inherited abstract method
#							bug 404649 - [1.8][compiler] detect illegal reference to indirect or redundant super
#							Bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis
#							Bug 415043 - [1.8][null] Follow-up re null type annotations after bug 392099
#							Bug 392238 - [1.8][compiler][null] Detect semantically invalid null type annotations
#							Bug 416307 - [1.8][compiler][null] subclass with type parameter substitution confuses null checking
#							Bug 400874 - [1.8][compiler] Inference infrastructure should evolve to meet JLS8 18.x (Part G of JSR335 spec)
#							Bug 424637 - [1.8][compiler][null] AIOOB in ReferenceExpression.resolveType with a method reference to Files::walk
#							Bug 418743 - [1.8][null] contradictory annotations on invocation of generic method not reported
#							Bug 416190 - [1.8][null] detect incompatible overrides due to null type annotations
#							Bug 392245 - [1.8][compiler][null] Define whether / how @NonNullByDefault applies to TYPE_USE locations
#							Bug 430150 - [1.8][null] stricter checking against type variables
#							Bug 434600 - Incorrect null analysis error reporting on type parameters
#							Bug 439516 - [1.8][null] NonNullByDefault wrongly applied to implicit type bound of binary type
#							Bug 438467 - [compiler][null] Better error position for "The method _ cannot implement the corresponding method _ due to incompatible nullness constraints"
#							Bug 458361 - [1.8][null] reconciler throws NPE in ProblemReporter.illegalReturnRedefinition()
#							Bug 410218 - Optional warning for arguments of "unexpected" types to Map#get(Object), Collection#remove(Object) et al.
#		Jesper S Moller <jesper@selskabet.org> - Contributions for
#							bug 382701 - [1.8][compiler] Implement semantic analysis of Lambda expressions & Reference expression
#							bug 384567 - [1.5][compiler] Compiler accepts illegal modifiers on package declaration
#							Bug 412153 - [1.8][compiler] Check validity of annotations which may be repeatable
#							Bug 412151 - [1.8][compiler] Check repeating annotation's collection type
#							Bug 419209 - [1.8] Repeating container annotations should be rejected in the presence of annotation it contains
#							Bug 527554 - [18.3] Compiler support for JEP 286 Local-Variable Type
###############################################################################
0 = {0}
1 = super cannot be used in java.lang.Object
2 = {0} cannot be resolved to a type
3 = The type {0} is not visible
4 = The type {0} is ambiguous
5 = The type {0} is deprecated
6 = The nested type {0} cannot be referenced using its binary name
7 = The type {0} is never used locally

15 = Incompatible operand types {0} and {1}
16 = Incompatible conditional operand types {0} and {1}
17 = Type mismatch: cannot convert from {0} to {1}
18 = The static member type {0}.{1} should be accessed directly
19 = Type mismatch: cannot convert from {0} to {1}
20 = No enclosing instance of type {0} is accessible to invoke the super constructor. Must define a constructor and explicitly qualify its super constructor invocation with an instance of {0} (e.g. x.super() where x is an instance of {0}).
21 = No enclosing instance of type {0} is accessible. Must qualify the allocation with an enclosing instance of type {0} (e.g. x.new A() where x is an instance of {0}).
22 = No enclosing instance of the type {0} is accessible in scope
23 = Illegal enclosing instance specification for type {0}
24 = Cannot define static initializer in inner type {0}
###[obsolete] 25 = Cannot refer to the non-final local variable {0} defined in an enclosing scope
26 = The member interface {0} can only be defined inside a top-level class or interface or in a static context
27 = Cannot use an expression of the type {0} as a valid enclosing instance
28 = No enclosing instance of type {0} is available due to some intermediate constructor invocation
29 = An anonymous class cannot subclass the final class {0}
30 = The member annotation {0} can only be defined inside a top-level class or interface or in a static context
31 = The member enum {0} can only be defined inside a top-level class or interface or in a static context
32 = The member enum {0} must be defined inside a static member type
33 = The type {0} is hiding the type {1}
34 = {0} is not an annotation type

50 = {0} cannot be resolved
51 = The local variable {0} may not have been initialized
52 = void is an invalid type for the variable {0}
###[obsolete] 53 = An array of void is an invalid type for the variable {0}
54 = void[] is an invalid type
55 = Duplicate local variable {0}
56 = Duplicate parameter {0}
57 = The final local variable {0} may already have been assigned
58 = The final local variable {0} cannot be assigned. It must be blank and not using a compound assignment
59 = The parameter {0} should not be assigned
60 = The final local variable {0} cannot be assigned, since it is defined in an enclosing type
61 = The value of the local variable {0} is not used
62 = The value of the parameter {0} is not used
63 = The code of method {0}({1}) is exceeding the 65535 bytes limit
64 = The code for the static initializer is exceeding the 65535 bytes limit
65 = Too many parameters, parameter {0} is exceeding the limit of 255 words eligible for method parameters
66 = Too many local variables, local variable {0} is exceeding the limit of 65535 words eligible for method local variables
67 = Too many synthetic parameters, emulated parameter {0} is exceeding the limit of 255 words eligible for method parameters
68 = Too many array dimensions. Maximum is 255
69 = The code of constructor {0}({1}) is exceeding the 65535 bytes limit
70 = {0} cannot be resolved or is not a field
71 = The field {1}.{0} is not visible
72 = The field {0} is ambiguous
73 = The field {0}.{1} is deprecated
74 = Cannot make a static reference to the non-static field {0}
75 = Cannot reference a field before it is defined
76 = The static field {0}.{1} should be accessed in a static way
77 = The value of the field {0}.{1} is not used
78 = The static field {0}.{1} should be accessed directly
79 = Unqualified access to the field {0}.{1} 
80 = The final field {0}.{1} cannot be assigned
81 = The blank final field {0} may not have been initialized
82 = The final field {0} may already have been assigned
83 = {0} cannot be resolved to a variable
84 = This static method of interface {0} can only be accessed as {0}.{1}
85 = The value of the exception parameter {0} is not used
86 = The code for the switch table on enum {0} is exceeding the 65535 bytes limit
87 = The operand stack is exceeding the 65535 bytes limit
88 = Internal inconsistency: Inappropriate operand stack size encountered during translation

90 = The local variable {0} is hiding another local variable defined in an enclosing scope
91 = The local variable {0} is hiding a field from type {1}
92 = The field {0}.{1} is hiding another local variable defined in an enclosing scope
93 = The field {0}.{1} is hiding a field from type {2}
94 = The parameter {0} is hiding another local variable defined in an enclosing scope
95 = The parameter {0} is hiding a field from type {1}
96 = The serializable class {0} does not declare a static final serialVersionUID field of type long
97 = Lambda expression''s parameter {0} cannot redeclare another local variable defined in an enclosing scope. 
98 = Lambda expression''s local variable {0} cannot redeclare another local variable defined in an enclosing scope. 
99 = The type {0} from the descriptor computed for the target context is not visible here.  
100 = The method {1}({2}) is undefined for the type {0}
101 = The method {1}({2}) from the type {0} is not visible
102 = The method {1}({2}) is ambiguous for the type {0}
103 = The method {1}({2}) from the type {0} is deprecated
104 = Cannot directly invoke the abstract method {1}({2}) for the type {0}
105 = Void methods cannot return a value
106 = Cannot return a void result
107 = This method requires a body instead of a semicolon
108 = This method must return a result of type {0}

110 = This method has a constructor name
111 = Return type for the method is missing
112 = Native methods do not specify a body
113 = Abstract methods do not specify a body
114 = Cannot invoke {1}({2}) on the primitive type {0}
115 = The method {1}({2}) in the type {0} is not applicable for the arguments ({3})
116 = Cannot invoke {1}({2}) on the array type {0}
117 = The static method {1}({2}) from the type {0} should be accessed in a static way
118 = The method {1}({2}) from the type {0} is never used locally
119 = The static method {1}({2}) from the type {0} should be accessed directly 
120 = The method {1}({2}) from the type {0} refers to the missing type {3}
121 = The method {1}({2}) from the type {0} can be declared as static
122 = The method {1}({2}) from the type {0} can potentially be declared as static
123 = Ambiguous method reference: both {1}({2}) and {3}({4}) from the type {0} are eligible
124 = The method {1}({2}) from the type {0} should be accessed in a static way 
125 = Incompatible parameter list for array constructor. Expected (int), but found ({1})
126 = Constructed array {0} cannot be assigned to {1} as required in the interface descriptor  
127 = The type {0} does not define {1}({2}) that is applicable here
128 = The type of {0}({1}) from the type {2} is {3}, this is incompatible with the descriptor''s return type: {4}
129 = The constructor {0}({1}) refers to the missing type {2}
130 = The constructor {0}({1}) is undefined
131 = The constructor {0}({1}) is not visible
132 = The constructor {0}({1}) is ambiguous
133 = The constructor {0}({1}) is deprecated
